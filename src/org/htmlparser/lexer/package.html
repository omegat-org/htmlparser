<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
<!--

  @(#)package.html  1.60 98/01/27

 HTMLParser Library v1_4_20030907 - A java-based parser for HTML
 Copyright (C) Dec 31, 2000 Somik Raha

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 For any questions or suggestions, you can write to me at :
 Email :somik@industriallogic.com

 Postal Address :
 Somik Raha
 Extreme Programmer & Coach
 Industrial Logic Corporation
 2583 Cedar Street, Berkeley,
 CA 94708, USA
 Website : http://www.industriallogic.com

-->
<TITLE>Lexer Package</TITLE>
</HEAD>
<BODY>
The lexer package will eventually be the base level I/O subsystem.
<EM>It is currently under development.</EM>
<P>The lexer package is responsible for reading characters from the HTML source
and identifying the node lexemes. For example, the HTML code below would return
the list of nodes shown:</P>
<PRE>
&lt;html&gt;&lt;head&gt;&lt;title&gt;Humoresque&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor='silver'&gt;
Passengers will please refrain
from flushing toilets while the train
is standing in the station. I love you!
&lt;p&gt;
We encourage constipation
while the train is in the station
If the train can't go
then why should you.
&lt;/body&gt;
&lt;/html&gt;
</PRE>
<OL>
<LI>line 0, offset 0, to line 0, offset 6, html tag</LI>
<LI>line 0, offset 6, to line 0, offset 12, head tag</LI>
<LI>line 0, offset 12, to line 0, offset 19, title tag</LI>
<LI>line 0, offset 19, to line 0, offset 29, string node "Humoresque"</LI>
<LI>line 0, offset 29, to line 0, offset 37, end title tag</LI>
<LI>line 0, offset 37, to line 0, offset 44, end head tag</LI>
<LI>line 0, offset 44, to line 0, offset 45, string node "\n"</LI>
<LI>line 1, offset 0, to line 1, offset 23, body tag</LI>
<LI>line 1, offset 23, to line 4, offset 40, string node "\nPassengers...you!\n"</LI>
<LI>line 5, offset 0,  to line 5, offset 2, paragraph tag</LI>
<LI>line 5, offset 3, to line 9, offset 21, string node "\nWe...you.\n"</LI>
<LI>line 10, offset 0, to line 10, offset 7, end body tag</LI>
<LI>line 10, offset 8, to line 10, offset 9, string "\n"</LI>
<LI>line 11, offset 0, to line 11, offset 7, html tag</LI>
<LI>line 11, offset 7, to line 11, offset 8, string node "\n"</LI>
</OL>
<p>Stream, Source, Page and Lexer
<p>The package is arranged in four levels, <CODE>Stream</CODE>,
<CODE>Source</CODE> <CODE>Page</CODE> and <CODE>Lexer</CODE> in the order of lowest to
highest.
A <CODE>Stream</CODE> is raw bytes from the URLConnection or file. It has no
intelligence. A <CODE>Source</CODE> is raw characters, hence it knows about the
encoding scheme used and can be reset if a different encoding is detected after
partially reading in the text. A <CODE>Page</CODE> provides characters from the
source while maintaining the index of line numbers, and hence can be thought of
as an array of strings corresponding to source file lines, but it doesn't
actually store any text, relying on the buffering within the
<CODE>Source</CODE> instead. The <CODE>Lexer</CODE> contains the actual lexeme parsing
code. It reads characters from the page, keeping track of where it is with a
<CODE>Cursor</CODE> and creates the array of nodes using various state
machines.
<p>
The following are some design goals and 'invariants' within the package, if you
are attempting to understand or modify it. Things that differ substantially from
previous implementations are highlighted in <B>bold</B>.
<DL>
<DT>Contiguous Nodes
<DD><B>Adjacent nodes have no characters between them.</B> The list of nodes forms an
uninterrupted chain that, by start and end definitions, completely covers the
characters that were read from the HTML source. Despite this, the nodes are not
stored in a linked list, but rather an array to ease any editing tasks that may
be performed.
<DT>Text Fidelity
<DD>Besides complete coverage, the <B>nodes do not contain copies of the text</B>,
but instead simply contain offsets into a single large buffer that contains the
text read from the HTML source. Even within tags, the attributes list can
contain whitespace, thus there is no lost whitespace or text formatting
either outside or within tags. Upper and lower case text is preserved.
<DT>Line Endings
<DD><B>End of line characters are just whitespace.</B> There is no distinction
made between end of line characters (or pairs of characters on Windows) and
other whitespace. The text is not read in line by line so nodes (tags) can easily span
multiple lines with no special processing. Line endings are not transformed
between platforms, i.e. Unix line endings are not converted to Windows line
endings by this level.  Each node will has a starting and ending location, which
the page can use to extract the text. To facilitate formatting error and log messages
the page can turn these offsets into row and column numbers. In general ignore line
breaks in the source if at all possible.
<DT>One Parser, One Scan
<DD>The Lexer has the following state machines corresponding
(roughly) to the <B>four parsers it replaces</B> (StringParser, RemarkNodeParser,
TagParser & AttributeParser):
<LI>in text - parseString()</LI>
<LI>in comment - parseRemark()</LI>
<LI>in tag - parseTag()</LI>
By integrating the four state machines into one, a single pass over the text is
all that's needed for a low level parse of the HTML source. In previous
implementations, the attributes were parsed on a second scan after the initial
tag was extracted.
<DT>Two Jars
<DD>For elementary operations at the node level, a minimalist jar file containing
<B>only the lexer and base tag classes</B> is split out from the larger <CODE>htmlparser.jar</CODE>.
In this way, simple parsing and output is handled with a jar file that is under
40 kilobytes, but anything beyond peephole manipulation, i.e. closing tag detection
and other semantic reasoning will need the full set of scanners, nodes and ancillary
classes, which now stands at 160 kilobytes.
</DL>
</BODY>
</HTML>
